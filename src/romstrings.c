/* m100rom.c */

/* $Id: romstrings.c),v 1.3 2008/03/26 09:38:33 kpettit1 Exp $ */

/*
 * Copyright 2004 Stephen Hurd and Ken Pettit
 *
 * Redistribution and use in source and binary forms), with or without
 * modification), are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice), this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice), this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES), INCLUDING), BUT NOT LIMITED TO), THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT), INDIRECT), INCIDENTAL), SPECIAL), EXEMPLARY), OR CONSEQUENTIAL
 * DAMAGES (INCLUDING), BUT NOT LIMITED TO), PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE), DATA), OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY), WHETHER IN CONTRACT), STRICT
 * LIABILITY), OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE), EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "roms.h"
#include "romstrings.h"

Std_ROM_Strings_t gDisStrings[] = {
	{ MTRM(R_FUN_VCTR_TBL),				"Function vector table for SGN to MID$" },
	{ MTRM(R_BASIC_TBL),				"BASIC statement keyword table END to NEW" },
	{ MTRM(R_FUN_TBL_TAB),				"Function keyword table TAB to <" },
	{ MTRM(R_FUN_TBL_SGN),				"Function keyword table SGN to MID$" },
	{ MTRM(R_BASIC_VCTR_TBL),			"BASIC statement vector table for END to NEW" },
	{ MTRM(R_MATH_VCTR_TBL),			"Vector table for math operations" },
	{ MTRM(R_BASIC_ERR_TXT),			"BASIC error message text" },
	{ MTRM(R_INIT_IMAGE),				"Initialization image loaded to F5F0H" },
	{ MTRM(R_XROM_DET_IMAGE),			"External ROM detect image loaded at F605H" },
	{ MTRM(R_BASIC_STRINGS),			"BASIC message strings" },
	{ MTRM(R_CAS_FREQ_CNT),				"Cassette frequency cycle count" },
	{ MTRM(R_TERM_FKEY_VCTR_TBL),		"TERM Mode function key vector table" },
	{ MTRM(R_DIR_DISP_ORDER_TBL),		"Directory file-type display order table" },
	{ MTRM(R_TEXT_FKEY_VCTR_TBL),		"TEXT Function key table - empty" },
	{ MTRM(R_ROM_CAT_ENTRIES),			"ROM programs catalog entries" },
	{ MTRM(R_INT_EXIT_FUN),				"Interrupt exit routine (pop all regs & RET)" },
	{ MTRM(R_8155_PIO_PAT1),			"8155 PIO chip bit patterns for Upper LCD drivers" },
	{ MTRM(R_8155_PIO_PAT2),			"8155 PIO chip bit patterns for Lower LCD drivers" },
	{ MTRM(R_INIT_CLK_VALUES),			"Initial clock chip register values" },
	{ MTRM(R_MENU_STRINGS),				"MENU Text Strings" },
	{ MTRM(R_MODEL_NUM_STRING),			"TRS-80 model number string" },
	{ MTRM(R_ACTIVE_SIGNATURE),			"Active system signature -- Warm vs Cold boot" },
	{ MTRM(R_HIMEM),					"HIMEM" },
	{ MTRM(R_RST_5_5_VCTR),				"RST 5.5 RAM Vector" },
	{ MTRM(R_RST_6_5_VCTR),				"RST 6.5 RAM Vector" },
	{ MTRM(R_RST_7_5_VCTR),				"RST 7.5 RAM Vector" },
	{ MTRM(R_TRAP_VCTR),            	"RAM vector for TRAP interrupt" },
	{ MTRM(R_OPTION_ROM_FLAG),      	"Option ROM flag" },
	{ MTRM(R_DIAL_SPEED),           	"Dial speed (1=10pps), 2=20pps" },
	{ MTRM(R_FKEY_STAT_TBL),        	"Function key status table (1 = on)" },
	{ MTRM(R_NEW_CONSOLE_FLAG),     	"New Console device flag" },
	{ MTRM(R_CURSOR_ROW),           	"Cursor row (1-8)" },
	{ MTRM(R_CURSOR_COL),           	"Cursor column (1-40)" },
	{ MTRM(R_ACTIVE_ROW_CNT),       	"Active rows count (1-8)" },
	{ MTRM(R_ACTIVE_COL_CNT),       	"Active columns count (1-40)" },
	{ MTRM(R_LABEL_LINE_PROT),      	"Label line protect status" },
	{ MTRM(R_SCROLL_DISABLE),       	"Scroll disable flag" },
	{ MTRM(R_CURSOR_STAT),          	"Cursor status (0 = off)" },
	{ MTRM(R_CURSOR_ROW2),          	"Cursor row (1-8)" },
	{ MTRM(R_CURSOR_COL2),          	"Cursor column (1-40)" },
	{ MTRM(R_ESC_MODE_FLAG),        	"ESC mode flag for RST 20H" },
	{ MTRM(R_REV_VID_SWITCH),       	"Reverse video switch" },
	{ MTRM(R_LAST_PLOT_X),          	"X coord of last point plotted" },
	{ MTRM(R_LAST_PLOT_Y),          	"Y coord of last point plotted" },
	{ MTRM(R_PWR_OFF_STAT),         	"Power off exit condition switch" },
	{ MTRM(R_DUPLEX_SWITCH),        	"Full/Half duplex switch" },
	{ MTRM(R_RS232_LF_SWITCH),      	"RS232 auto linefeed switch" },
	{ MTRM(R_RS232_PARAM_TBL),      	"RS232 parameter setting table" },
	{ MTRM(R_ADDRESS_LAST_CALLED),  	"Address last called" },
	{ MTRM(R_OUT_STMT_HOOK),        	"OUT statement hook" },
	{ MTRM(R_INP_STMT_HOOK),        	"INP function hook" },
	{ MTRM(R_LAST_ERROR_CODE),      	"Last Error code" },
	{ MTRM(R_LPT_HEAD_POS),         	"Line printer head position" },
	{ MTRM(R_OUTPUT_DEVICE),        	"Output device for RST 20H (0=screen)" },
	{ MTRM(R_BASIC_STR_BUF_PTR),    	"BASIC string buffer pointer" },
	{ MTRM(R_CUR_BASIC_LINE_NUM),   	"Current executing line number" },
	{ MTRM(R_START_BASIC_PGM_PTR),  	"Start of BASIC program pointer" },
	{ MTRM(R_END_OF_STMT_MARKER),   	"End of statement marker" },
	{ MTRM(R_KEYBOARD_BUF),         	"Keyboard buffer" },
	{ MTRM(R_CURSOR_H_POS),         	"Horiz. position of cursor (0-39)" },
	{ MTRM(R_FKEY_DEF_BUF),         	"Function key definition area" },
	{ MTRM(R_BASIC_FKEY_DEF_BUF),   	"Function key definition area (BASIC)" },
	{ MTRM(R_FILE_RAM_END),         	"End of RAM for file storage" },
	{ MTRM(R_SEC_ONES),             	"Seconds (ones)" },
	{ MTRM(R_SEC_TENS),             	"Seconds (tens)" },
	{ MTRM(R_MIN_ONES),             	"Minutes (ones)" },
	{ MTRM(R_MIN_TENS),             	"Minutes (tens)" },
	{ MTRM(R_HR_ONES),              	"Hours (ones)" },
	{ MTRM(R_HR_TENS),              	"Hours (tens)" },
	{ MTRM(R_DATE_ONES),            	"Date (ones)" },
	{ MTRM(R_DATE_TENS),            	"Date (tens)" },
	{ MTRM(R_DAY_CODE),             	"Day code (0=Sun), 1=Mon), etc.)" },
	{ MTRM(R_MONTH),                	"Month (1-12)" },
	{ MTRM(R_YEAR_ONES),            	"Year (ones)" },
	{ MTRM(R_YEAR_TENS),            	"Year (tens)" },
	{ MTRM(R_SEC_ONES2),            	"Seconds (ones)" },
	{ MTRM(R_SEC_TENS2),            	"Seconds (tens)" },
	{ MTRM(R_MIN_ONES2),            	"Minutes (ones)" },
	{ MTRM(R_MIN_TENS2),            	"Minutes (tens)" },
	{ MTRM(R_HR_ONES2),             	"Hours (ones)" },
	{ MTRM(R_HR_TENS2),             	"Hours (tens)" },
	{ MTRM(R_DATE_ONES2),           	"Date (ones)" },
	{ MTRM(R_DATE_TENS2),           	"Date (tens)" },
	{ MTRM(R_DAY_CODE2),            	"Day code (0=Sun), 1=Mon), etc.)" },
	{ MTRM(R_ONTIME_TIME),          	"Time for ON TIME interrupt (SSHHMM)" },
	{ MTRM(R_ONCOM_FLAG),           	"On Com flag" },
	{ MTRM(R_ONCOM_ADDRESS),        	"On Com routine address" },
	{ MTRM(R_ONTIME_FLAG),          	"On Time flag" },
	{ MTRM(R_ONTIME_ADDRESS),       	"On Time routine address" },
	{ MTRM(R_FKEY_VCTR_TBL),        	"Function key vector table" },
	{ MTRM(R_DIR_RAM_START),        	"Start of RAM directory" },
	{ MTRM(R_UNSAVED_BASIC_PTR),    	"BASIC program not saved pointer" },
	{ MTRM(R_PASTE_RAM_START),      	"Start of Paste Buffer" },
	{ MTRM(R_LAST_CHAR_PRINTED),    	"Last char sent to printer" },
	{ MTRM(R_LABEL_ENABLE_FLAG),    	"Label line enable flag" },
	{ MTRM(R_PORT_A8H),             	"Contents of port A8H" },
	{ MTRM(R_IPL_FILENAME_START),   	"Start of IPL filename" },
	{ MTRM(R_BASIC_LIST_START),     	"Address where last BASIC list started" },
	{ MTRM(R_SP_SAVE_BUF),          	"SP save area for power up/down" },
	{ MTRM(R_LOWEST_RAM),           	"Lowest RAM address used by system" },
	{ MTRM(R_RST_38H_OFFSET),       	"Offset of last RST 38H call" },
	{ MTRM(R_LAST_PGRM_LEN),        	"Length of last program loaded/saved to tape" },
	{ MTRM(R_RST_38H_VCTR_TBL),     	"Start of RST 38H vector table" },
	{ MTRM(R_LCD_OUTPUT_HOOK),      	"LCD character output hook" },
	{ MTRM(R_LPT_OUTPUT_HOOK),      	"Printer character output hook" },
	{ MTRM(R_EOF_FUN_HOOK),         	"EOF function hook" },
	{ MTRM(R_TERM_F6_HOOK),         	"Term F6 hook" },
	{ MTRM(R_TERM_F7_HOOK),         	"Term F7 hook" },
	{ MTRM(R_WIDTH_STMT_HOOK),      	"WIDTH statement hook" },
	{ MTRM(R_CRT_OPEN_HOOK),        	"CRT open routine hook" },
	{ MTRM(R_CRT_OUTPUT_HOOK),      	"CRT output file routine hook" },
	{ MTRM(R_WAND_OPEN_HOOK),       	"WAND Open routine hook" },
	{ MTRM(R_WAND_CLOSE_HOOK),      	"WAND Close routine hook" },
	{ MTRM(R_WAND_GET_HOOK),        	"WAND Get routine hook" },
	{ MTRM(R_WAND_IO_HOOK),         	"WAND Special I/O routine hook" },
	{ MTRM(R_LOF_HOOK),             	"LOF function hook" },
	{ MTRM(R_LOC_HOOK),             	"LOC function hook" },
	{ MTRM(R_LFILES_HOOK),          	"LFILES statement hook" },
	{ MTRM(R_DSKI_HOOK),            	"DSKI$ routine hook" },
	{ MTRM(R_DSKO_HOOK),            	"DSKO$ routine hook" },
	{ MTRM(R_VAR_CREATE_LOC_FLAG),  	"Variable Create/Locate switch" },
	{ MTRM(R_LAST_VAR_TYPE),        	"Type of last variable used" },
	{ MTRM(R_FILE_BUF_PTR),         	"File buffer area pointer" },
	{ MTRM(R_DATA_STMT_LINE_NUM),   	"Line number of current data statement" },
	{ MTRM(R_FOR_NEXT_ACTIVE_FLAG), 	"FOR/NEXT loop active flag" },
	{ MTRM(R_LAST_VAR_ASSIGNED_ADDR),	"Address of last variable assigned" },
	{ MTRM(R_RUNNING_LINE_NUM_ADDR),	"Most recent or currenly running line pointer" },
	{ MTRM(R_BASIC_SP_BUF),         	"SP used by BASIC to reinitialize the stack" },
	{ MTRM(R_LAST_ERR_LINE_NUM),    	"Line number of last error" },
	{ MTRM(R_LAST_ENTERED_LINE_NUM),	"Most recent used or entered line number" },
	{ MTRM(R_ERR_PTR),              	"Pointer to occurance of error" },
	{ MTRM(R_ONERROR_ADDRESS),      	"Address of ON ERROR routine" },
	{ MTRM(R_BREAK_LINE_NUM),       	"Line where break), END), or STOP occurred" },
	{ MTRM(R_BREAK_ADDRESS),        	"Address where program stopped on last break), END), or STOP" },
	{ MTRM(R_DO_FILES_PTR),         	"Start of DO files pointer" },
	{ MTRM(R_CO_FILES_PTR),         	"Start of CO files pointer" },
	{ MTRM(R_VAR_PTR),              	"Start of variable data pointer" },
	{ MTRM(R_ARRAY_TBL_PTR),        	"Start of array table pointer" },
	{ MTRM(R_UNUSED_MEM_PTR),       	"Unused memory pointer" },
	{ MTRM(R_DATA_SEARCH_ADDR),     	"Address where DATA search will begin next" },
	{ MTRM(R_DEF_TBL),              	"DEF definition table" },
	{ MTRM(R_FP_TEMP1),           		"Floating Point Temp 1" },
	{ MTRM(R_FP_TEMP2),           		"Floating Point Temp 2" },
	{ MTRM(R_FP_TEMP3),					"Floating Point Temp 3" },
	{ MTRM(R_FP_FAC1),              	"Start of FAC1 for single and double precision" },
	{ MTRM(R_INT_FAC1),             	"Start of FAC1 for integers" },
	{ MTRM(R_FP_FAC2),              	"Start of FAC2 for single and double precision" },
	{ MTRM(R_INT_FAC2),             	"Start of FAC2 for integers" },
	{ MTRM(R_MAXFILES),             	"Maxfiles" },
	{ MTRM(R_FILE_NUM_TBL_PTR),     	"File number description table pointer" },
	{ MTRM(R_BASIC_FILENAME),       	"Filename of current BASIC program" },
	{ MTRM(R_LAST_LOAD_FILENAME),   	"Filename of last program loaded from tape" },
	{ MTRM(R_ALT_LCD_CHAR_BUF),     	"Start of Alt LCD character buffer" },
	{ MTRM(R_MENU_TO_RAM_MAP),      	"Map of MENU entry positions to RAM directory positions" },
	{ MTRM(R_MENU_OR_CMD_FLAG),     	"Flag to indicate MENU entry location or command entry" },
	{ MTRM(R_CUR_MENU_DIR_LOC),     	"Current MENU directory location" },
	{ MTRM(R_MAX_MENU_DIR_LOC),     	"Maximum MENU directory location" },
	{ MTRM(R_LCD_CHAR_BUF),         	"Start of LCD character buffer" },
	{ MTRM(R_XON_XOFF_CTRL),        	"XON/XOFF protocol control" },
	{ MTRM(R_XON_XOFF_ENABLE),      	"XON/XOFF enable flag" },
	{ MTRM(R_RS232_INIT_STAT),      	"RS232 initialization status" },
	{ MTRM(R_SOUND_FLAG),           	"Sound flag" },
	{ MTRM(R_PORT_E8H),             	"Contents of port E8H" },
	{ MTRM(R_RS232_CHAR_BUF),       	"RS232 Character buffer" },
	{ MTRM(R_RS232_BUF_CNT),        	"RS232 buffer count" },
	{ MTRM(R_RS232_BUF_OUT),        	"RS232 buffer output position" },
	{ MTRM(R_RS232_BUF_IN),         	"RS232 buffer input pointer" },
	{ MTRM(R_CTRL_S_STAT),          	"Control-S status" },
	{ MTRM(R_UART_BAUD_TIMER_VAL),  	"UART baud rate timer value" },
	{ MTRM(R_RS232_PARITY_CTRL),    	"RS232 Parity Control byte" },
	{ MTRM(R_CAS_PULSE_CTRL),       	"Cassette port pulse control" },
	{ MTRM(R_SPEC_KEY_STAT),        	"Special key status storage" },
	{ MTRM(R_FKEY_STAT),            	"Function key status storage" },
	{ MTRM(R_KEY_SCAN_STORAGE1),    	"Keyboard scan column storage #1" },
	{ MTRM(R_KEY_SCAN_STORAGE2),    	"Keyboard scan column storage @2" },
	{ MTRM(R_SHIFT_KEY_STAT),       	"Shift key status storage" },
	{ MTRM(R_KEY_REPT_START),       	"Key repeat start delay counter" },
	{ MTRM(R_KEY_POSITION),         	"Key position storage" },
	{ MTRM(R_2ND_KEY_BUF_PTR),      	"Pointer to entry in 2nd Storage Buffer for key" },
	{ MTRM(R_KEY_BUF_CNT),          	"Keyboard buffer count" },
	{ MTRM(R_KEY_TYPEAHEAD_BUF),   		"Keyboard typeahead buffer" },
	{ MTRM(R_CURSOR_BIT_PAT_BUF),   	"Cursor bit pattern storage" },
	{ MTRM(R_CUR_PROG_LOAD_ADDR),		"'Load address' of current program" },

	/* ROM Functions */

	{ MTRM(R_RESET_VECTOR),				"Reset Vector" },
	{ MTRM(R_COMP_BYTE_M),				"Compare next byte with M" },
	{ MTRM(R_GET_NONWHITE),				"Get next non-white char from M" },
	{ MTRM(R_COMP_DE_HL),				"Compare DE and HL" },
	{ MTRM(R_PRINT_SPACE),				"Send a space to screen/printer" },
	{ MTRM(R_PRINT_CHAR),				"Send character in A to screen/printer" },
	{ MTRM(R_PWR_DOWN_TRAP),			"Power down TRAP" },
	{ MTRM(R_DET_LAST_VAR_TYPE),		"Determine type of last var used" },
	{ MTRM(R_RST_5_5),					"RST 5.5 -- Bar Code Reader" },
	{ MTRM(R_GET_FAC1_SIGN),			"Get sign of FAC1" },
	{ MTRM(R_RST_6_5),					"RST 6.5 -- RS232 character pending" },
	{ MTRM(R_RAM_VCTR_TBL_DRIVER),		"RAM vector table driver" },
	{ MTRM(R_RST_7_5),					"RST 7.5 -- Timer background task" },
	{ MTRM(R_BASIC_KEYWORD_TBL),		"BASIC statement keyword table END to NEW" },
	{ MTRM(R_FUN_KEYWORD_TBL1),			"Function keyword table TAB to <" },
	{ MTRM(R_FUN_KEYWORD_TBL2),			"Function keyword table SGN to MID$" },
	{ MTRM(R_BASIC_VECTOR_TBL),			"BASIC statement vector table for END to NEW" },
	{ MTRM(R_MATH_PRIORITY_TBL),		"Math operator priority table" },
	{ MTRM(R_BASIC_ERR_MSG_TXT),		"BASIC error message text" },
	{ MTRM(R_FUN_INIT_IMAGE),			"Initialization image loaded to F5F0H" },
	{ MTRM(R_FUN_XROM_IMAGE),			"External ROM detect image loaded at F605H" },
	{ MTRM(R_FUN_BASIC_STRINGS),		"BASIC message strings" },
	{ MTRM(R_POP_FOR_NEXT),				"Pop return address for NEXT or RETURN" },
	{ MTRM(R_INIT_AND_READY),			"Initialize system and go to BASIC ready" },
	{ MTRM(R_GEN_SN_ERROR),				"Generate Syntax error" },
	{ MTRM(R_GEN_d0_ERROR),				"Generate /0 error" },
	{ MTRM(R_GEN_NF_ERROR),				"Generate NF error" },
	{ MTRM(R_GEN_DD_ERROR),				"Generate DD error" },
	{ MTRM(R_GEN_RW_ERROR),				"Generate RW error" },
	{ MTRM(R_GEN_OV_ERROR),				"Generate OV error" },
	{ MTRM(R_GEN_MO_ERROR),				"Generate MO error" },
	{ MTRM(R_GEN_TM_ERROR),				"Generate TM error" },
	{ MTRM(R_GEN_ERR_IN_E),				"Generate error in E" },
	{ MTRM(R_RESTORE_JMP_BC),			"Restore stack & runtime and jump to BC" },
	{ MTRM(R_PRINT_BASIC_ERR),			"Print BASIC error message - XX error in XXX" },
	{ MTRM(R_POP_GO_BASIC_RDY),			"Pop stack and vector to BASIC ready" },
	{ MTRM(R_GO_BASIC_RDY_OK),			"Vector to BASIC ready - print Ok" },
	{ MTRM(R_GO_BASIC_RDY),				"Silent vector to BASIC ready" },
	{ MTRM(R_PERFORM_M_GO_RDY),			"Perform operation at M and return to ready" },
	{ MTRM(R_UPDATE_LINE_ADDR),			"Update line addresses for current BASIC program" },
	{ MTRM(R_EVAL_LIST_ARGS),			"Evaluate LIST statement arguments" },
	{ MTRM(R_FIND_LINE_IN_DE),			"Find line number in DE" },
	{ MTRM(R_FIND_LINE_DE_AT_HL),		"Find line number in DE starting at HL" },
	{ MTRM(R_TOKEN_COMPRESS),			"Perform Token compression" },
	{ MTRM(R_FOR_STMT),					"FOR statement" },
	{ MTRM(R_TO_STMT),					"TO statement" },
	{ MTRM(R_STEP_STMT),				"STEP statement" },
	{ MTRM(R_RUN_BASIC_PGRM),			"Execute BASIC program" },
	{ MTRM(R_RUN_BASIC_AT_HL),			"Start executing BASIC program at HL" },
	{ MTRM(R_EXEC_INST_IN_A),			"Execute instruction in A), HL points to args" },
	{ MTRM(R_RST_10H_INC_HL),			"RST 10H routine with pre-increment of HL" },
	{ MTRM(R_RST_10H),					"RST 10H routine" },
	{ MTRM(R_DEF_STMT),					"DEF statement" },
	{ MTRM(R_DEFDBL_STMT),				"DEFDBL statement" },
	{ MTRM(R_DEFINT_STMT),				"DEFINT statement" },
	{ MTRM(R_DEFSNG_STMT),				"DEFSNG statement" },
	{ MTRM(R_DEFSTR_STMT),				"DEFSTR statement" },
	{ MTRM(R_DECL_VAR_TYPE_E),			"Declare variable at M to be type E" },
	{ MTRM(R_GEN_FC_ERROR),				"Generate FC error" },
	{ MTRM(R_EVAL_LINE_NUM),			"Evaluate line number text at M" },
	{ MTRM(R_ASCII_TO_BIN),				"Convert ASCII number at M to binary" },
	{ MTRM(R_ASCII_TO_BIN_PREINC),		"Convert ASCII number at M+1 to binary" },
	{ MTRM(R_RUN_STMT),					"RUN statement" },
	{ MTRM(R_GOSUB_STMT),				"GOSUB statement" },
	{ MTRM(R_GOTO_STMT),				"GOTO statement" },
	{ MTRM(R_GEN_UL_ERROR),				"Generate UL error" },
	{ MTRM(R_RETURN_STMT),				"RETURN statement" },
	{ MTRM(R_DATA_STMT),				"DATA statement" },
	{ MTRM(R_REM_STMT),					"REM statement" },
	{ MTRM(R_LET_STMT),					"LET statement" },
	{ MTRM(R_ON_STMT),					"ON statement" },
	{ MTRM(R_ON_ERROR_STMT),			"ON ERROR statement" },
	{ MTRM(R_ON_KEY_STMT),				"ON KEY/TIME/COM/MDM GOSUB routine" },
	{ MTRM(R_ON_TIME_STMT),				"ON TIME$ handler" },
	{ MTRM(R_RESUME_STMT),				"RESUME statement" },
	{ MTRM(R_ERROR_STMT),				"ERROR statement" },
	{ MTRM(R_IF_STMT),					"IF statement" },
	{ MTRM(R_LPRINT_STMT),				"LPRINT statement" },
	{ MTRM(R_PRINT_STMT),				"PRINT statement" },
	{ MTRM(R_TAB_STMT),					"TAB statement" },
	{ MTRM(R_LINE_STMT),				"LINE statement" },
	{ MTRM(R_INPUT_NO_STMT),			"INPUT # statement" },
	{ MTRM(R_INPUT_STMT),				"INPUT statement" },
	{ MTRM(R_READ_STMT),				"READ statement" },
	{ MTRM(R_EVAL_BASIC_INST),			"Main BASIC evaluation routine" },
	{ MTRM(R_INT16_DIV),				"Integer Divide FAC1=DE/HL" },
	{ MTRM(R_EVAL_FUN),					"Evaluate function at M" },
	{ MTRM(R_ERR_FUN),					"ERR function" },
	{ MTRM(R_ERL_FUN),					"ERL function" },
	{ MTRM(R_VARPTR_FUN),				"VARPTR function" },
	{ MTRM(R_VARPTR_BUF_FUN),			"VARPTR(#buffer) function" },
	{ MTRM(R_VARPTR_VAR_FUN),			"VARPTR(variable) function" },
	{ MTRM(R_EVAL_VAR),					"Evaluate variable" },
	{ MTRM(R_CONV_M_TOUPPER),			"Get char at M and convert to uppercase" },
	{ MTRM(R_CONV_A_TOUPPER),			"Convert A to uppercase" },
	{ MTRM(R_ASCII_NUM_CONV),			"ASCII num conversion - find ASCII or tokenized '+' or '-' in A" },
	{ MTRM(R_NOT_FUN),					"NOT function" },
	{ MTRM(R_RST_28H),					"RST 28H routine" },
	{ MTRM(R_OR_FUN),					"OR function" },
	{ MTRM(R_AND_FUN),					"AND function" },
	{ MTRM(R_XOR_FUN),					"XOR function" },
	{ MTRM(R_EQV_FUN),					"EQV function" },
	{ MTRM(R_IMP_FUN),					"IMP function" },
	{ MTRM(R_LPOS_FUN),					"LPOS function" },
	{ MTRM(R_POS_FUN),					"POS function" },
	{ MTRM(R_LD_FAC1_INT),				"Load integer in A into FAC1" },
	{ MTRM(R_CHK_RUNNING_PGRM),			"Check for running program" },
	{ MTRM(R_GEN_ID_ERROR),				"Generate ID error" },
	{ MTRM(R_INP_FUN),					"INP function" },
	{ MTRM(R_OUT_STMT),					"OUT statement" },
	{ MTRM(R_EVAL_EXPR),				"Evaluate expression at M" },
	{ MTRM(R_EVAL_EXPR_PREDEC),			"Evaluate expression at M-1" },
	{ MTRM(R_LLIST_STMT),				"LLIST statement" },
	{ MTRM(R_LIST_STMT),				"LIST statement" },
	{ MTRM(R_BUF_TO_LCD),				"Send buffer at M to screen" },
	{ MTRM(R_PEEK_FUN),					"PEEK function" },
	{ MTRM(R_POKE_FUN),					"POKE function" },
	{ MTRM(R_WAIT_KEY),					"Wait for key from keyboard" },
	{ MTRM(R_TOGGLE_LABEL),				"Toggle function key label line" },
	{ MTRM(R_CHK_KEY_QUEUE),			"Check keyboard queue for pending characters" },
	{ MTRM(R_POWER_STMT),				"POWER statement" },
	{ MTRM(R_LOW_PWR_TRAP),				"Normal TRAP (low power) interrupt routine" },
	{ MTRM(R_POWER_DOWN),				"Turn off computer" },
	{ MTRM(R_POWER_CONT_STMT),			"POWER CONT statement" },
	{ MTRM(R_POWER_ON_STMT),			"POWER ON statement" },
	{ MTRM(R_OUT_CH_TO_LPT),			"Output character to printer" },
	{ MTRM(R_LOAD_CAS_HDR),				"Start tape and load tape header" },
	{ MTRM(R_GEN_IO_ERROR),				"Generate I/O error" },
	{ MTRM(R_DET_CAS_SYNC_HDR),			"Turn cassette motor on and detect sync header" },
	{ MTRM(R_CAS_MOTOR_ON),				"Turn cassette motor on" },
	{ MTRM(R_CAS_MOTOR_OFF),			"Turn cassette motor off" },
	{ MTRM(R_CAS_READ_BYTE),			"Read byte from tape & update checksum" },
	{ MTRM(R_CAS_WRITE_BYTE),			"Write byte to tape & update checksum" },
	{ MTRM(R_LCD_DCB),					"LCD Device control block" },
	{ MTRM(R_LCD_OPEN),					"LCD and PRT file open routine" },
	{ MTRM(R_LCD_OUT),					"Output to LCD file" },
	{ MTRM(R_POP_ALL_REGS),				"Pop AF), BC), DE), HL from stack" },
	{ MTRM(R_CRT_DCB),					"CRT device control block" },
	{ MTRM(R_RAM_DCB),					"RAM device control block" },
	{ MTRM(R_RAM_OPEN),					"Open RAM file" },
	{ MTRM(R_RAM_CLOSE),				"Close RAM file" },
	{ MTRM(R_RAM_OUT),					"Output to RAM file" },
	{ MTRM(R_RAM_IN),					"Input from RAM file" },
	{ MTRM(R_RAM_IO),					"Special RAM file I/O" },
	{ MTRM(R_CAS_DCB),					"CAS device control block" },
	{ MTRM(R_CAS_OPEN),					"Open CAS file" },
	{ MTRM(R_CAS_CLOSE),				"Close CAS file" },
	{ MTRM(R_CAS_OUT),					"Output to CAS file" },
	{ MTRM(R_CAS_IN),					"Input from CAS file" },
	{ MTRM(R_LPT_DCB),					"LPT device control block" },
	{ MTRM(R_LPT_OUT),					"Output to LPT file" },
	{ MTRM(R_COM_DCB),					"COM device control block" },
	{ MTRM(R_MDM_OPEN),					"Open MDM file" },
	{ MTRM(R_COM_OPEN),					"Open COM file" },
	{ MTRM(R_COM_CLOSE),				"Close COM file" },
	{ MTRM(R_COM_OUT),					"Output to COM/MDM file" },
	{ MTRM(R_COM_IN),					"Input from COM/MDM file" },
	{ MTRM(R_COM_IO),					"Special COM/MDM file I/O" },
	{ MTRM(R_MDM_DCB),					"MDM Device control block" },
	{ MTRM(R_MDM_CLOSE),				"Close MDM file" },
	{ MTRM(R_SET_RS232_PARAMS),			"Set RS232 parameters from string at M" },
	{ MTRM(R_BCR_DCB),					"Wand device control block" },
	{ MTRM(R_EOF_FUN),					"EOF function" },
	{ MTRM(R_TIME_FUN),					"TIME$ function" },
	{ MTRM(R_READ_TIME),				"Read time and store it at M" },
	{ MTRM(R_DATE_FUN),					"DATE$ function" },
	{ MTRM(R_DAY_FUN),					"DAY function" },
	{ MTRM(R_READ_DAY),					"Read day and store at M" },
	{ MTRM(R_UPDATE_CLK_VALUES),		"Update in-memory (F923H) clock values" },
	{ MTRM(R_TIME_STMT),				"TIME$ statement" },
	{ MTRM(R_UPDATE_CLK_CHIP),			"Update clock chip from memory F923H" },
	{ MTRM(R_DATE_STMT),				"DATE$ statement" },
	{ MTRM(R_DAY_STMT),					"DAY$ statement" },
	{ MTRM(R_GET_TIME_STRING),			"Get time string from command line" },
	{ MTRM(R_IPL_STMT),					"IPL statement" },
	{ MTRM(R_ERASE_IPL_PRGM),			"Erase current IPL program" },
	{ MTRM(R_COM_MDM_STMT),				"COM and MDM statements" },
	{ MTRM(R_KEY_FUN),					"KEY() statement" },
	{ MTRM(R_KEY_ON_OFF_STMT),			"KEY STOP/ON/OFF statements" },
	{ MTRM(R_DET_TIME_ARG),				"Determine argument (ON/OFF/STOP) for TIME$ statement" },
	{ MTRM(R_DET_DEVICE_ARG),			"Determine device (KEY/TIME/COM/MDM) for ON GOSUB" },
	{ MTRM(R_ONTIME_STMT),				"ON TIME$ statement" },
	{ MTRM(R_ONCOM_STMT),				"ON COM handler" },
	{ MTRM(R_RST7_5_ISR),				"RST 7.5 interrupt routine" },
	{ MTRM(R_KICK_PWR_OFF_WDT),			"Renew automatic power-off counter" },
	{ MTRM(R_KEY_STMT),					"KEY statement" },
	{ MTRM(R_KEY_LIST_STMT),			"KEY LIST statement" },
	{ MTRM(R_SEND_CHARS_TO_LCD),		"Send B characters from M to the screen" },
	{ MTRM(R_PSET_STMT),				"PSET statement" },
	{ MTRM(R_PRESET_STMT),				"PRESET statement" },
	{ MTRM(R_DRAW_FBOX),				"Draw a filled box on LCD. Coords are on stack" },
	{ MTRM(R_DRAW_BOX),					"Draw an unfilled box on LCD. Coords are on stack" },
	{ MTRM(R_TOKENIZE_XY),				"Get (X),Y) coordinate from tokenized string at M" },
	{ MTRM(R_CSRLIN_FUN),				"CSRLIN function" },
	{ MTRM(R_MAX_FUN),					"MAX function" },
	{ MTRM(R_MAXRAM_FUN),				"MAXRAM function" },
	{ MTRM(R_MAXFILES_FUN),				"MAXFILES function" },
	{ MTRM(R_HIMEM_FUN),				"HIMEM function" },
	{ MTRM(R_WIDTH_STMT),				"WIDTH statement" },
	{ MTRM(R_SOUND_STMT),				"SOUND statement" },
	{ MTRM(R_SOUND_OFF_STMT),			"SOUND OFF statement" },
	{ MTRM(R_SOUND_ON_STMT),			"SOUND ON statement" },
	{ MTRM(R_MOTOR_STMT),				"MOTOR statement" },
	{ MTRM(R_MOTOR_ON_STMT),			"MOTOR ON statement" },
	{ MTRM(R_MOTOR_OFF_STMT),			"MOTOR OFF statement" },
	{ MTRM(R_CALL_STMT),				"CALL statement" },
	{ MTRM(R_SCREEN_STMT),				"SCREEN statement" },
	{ MTRM(R_LCOPY_STMT),				"LCOPY statement" },
	{ MTRM(R_FILES_STMT),				"FILES statement" },
	{ MTRM(R_DISPLAY_CAT),				"Display Catalog" },
	{ MTRM(R_KILL_STMT),				"KILL statement" },
	{ MTRM(R_KILL_TEXT_FILE),			"Kill a text file" },
	{ MTRM(R_NAME_STMT),				"NAME statement" },
	{ MTRM(R_NEW_STMT),					"NEW statement" },
	{ MTRM(R_STRLEN),					"Count length of string at M" },
	{ MTRM(R_GET_FIND_DO_FILE),			"Get .DO filename and locate in RAM directory" },
	{ MTRM(R_OPEN_TEXT_FILE),			"Open a text file at (FC93H)" },
	{ MTRM(R_CSAVE_STMT),				"CSAVE statement" },
	{ MTRM(R_CAS_WRITE_BUF),			"Save buffer at M to tape" },
	{ MTRM(R_SAVEM_STMT),				"SAVEM statement" },
	{ MTRM(R_CSAVEM_STMT),				"CSAVEM statement" },
	{ MTRM(R_CLOAD_STMT),				"CLOAD statement" },
	{ MTRM(R_CAS_READ_REC),				"Load record from tape and store at M" },
	{ MTRM(R_GEN_VERIFY_FAIL_ERR),		"Generate Verify Failed error" },
	{ MTRM(R_LOADM_STMT),				"LOADM and RUNM statement" },
	{ MTRM(R_CLOADM_STMT),				"CLOADM statement" },
	{ MTRM(R_MOVE_B_BYTES),				"Move B bytes from M to (DE)" },
	{ MTRM(R_EXEC_CO_FILE),				"Launch .CO files from MENU" },
	{ MTRM(R_CAS_OPEN_OUT_BA),			"Open CAS for output of BASIC files" },
	{ MTRM(R_CAS_OPEN_OUT_DO),			"Open CAS for output of TEXT files" },
	{ MTRM(R_CAS_OPEN_OUT_CO),			"Open CAS for output of CO files" },
	{ MTRM(R_CAS_OPEN_IN_BA),			"Open CAS for input of BASIC files" },
	{ MTRM(R_CAS_OPEN_IN_DO),			"Open CAS for input of TEXT files" },
	{ MTRM(R_CAS_OPEN_IN_CO),			"Open CAS for input of CO files" },
	{ MTRM(R_STR_FUN),					"STR$ function" },
	{ MTRM(R_PRINT_STRING),				"Print buffer at M until NULL or '\"'" },
	{ MTRM(R_MOVE_L_BYTES),				"Move L bytes from (BC) to (DE)" },
	{ MTRM(R_LEN_FUN),					"LEN function" },
	{ MTRM(R_ASC_FUN),					"ASC function" },
	{ MTRM(R_CHR_FUN),					"CHR$ function" },
	{ MTRM(R_STRING_FUN),				"STRING$ function" },
	{ MTRM(R_SPACE_FUN),				"SPACE$ function" },
	{ MTRM(R_LEFT_FUN),					"LEFT$ function" },
	{ MTRM(R_RIGHT_FUN),				"RIGHT$ function" },
	{ MTRM(R_MID_FUN),					"MID$ function" },
	{ MTRM(R_VAL_FUN),					"VAL function" },
	{ MTRM(R_INSTR_FUN),				"INSTR function" },
	{ MTRM(R_FRE_FUN),					"FRE function" },
	{ MTRM(R_DBL_SUB),					"Double precision subtract (FAC1=FAC1-FAC2)" },
	{ MTRM(R_DBL_ADD),					"Double precision addition (FAC1=FAC1+FAC2)" },
	{ MTRM(R_BCD_ADD),					"Add the BCD num in M to the one in (DE)" },
	{ MTRM(R_DBL_MULT),					"Double precision multiply (FAC1=FAC1*FAC2)" },
	{ MTRM(R_DBL_DIV),					"Double precision divide (FAC1=FAC1/FAC2)" },
	{ MTRM(R_MOVE_C_BYTES),				"Move C bytes from M to (DE)" },
	{ MTRM(R_COS_FUN),					"COS function" },
	{ MTRM(R_SIN_FUN),					"SIN function" },
	{ MTRM(R_TAN_FUN),					"TAN function" },
	{ MTRM(R_ATN_FUN),					"ATN function" },
	{ MTRM(R_LOG_FUN),					"LOG function" },
	{ MTRM(R_SQR_FUN),					"SQR function" },
	{ MTRM(R_EXP_FUN),					"EXP function" },
	{ MTRM(R_RND_FUN),					"RND function" },
	{ MTRM(R_DBL_SQR),					"Double precision Square (FAC1=SQR(FAC1))" },
	{ MTRM(R_MULT_M_FAC2),				"Double precision math (FAC1=M * FAC2))" },
	{ MTRM(R_FAC2_EQ_FAC1),				"Move FAC1 to FAC2" },
	{ MTRM(R_FAC2_EQ_FP),				"Move floating point number M to FAC2" },
	{ MTRM(R_FAC1_EQ_FAC2),				"Move FAC2 to FAC1" },
	{ MTRM(R_FAC1_EQ_FP),				"Move floating point number M to FAC1" },
	{ MTRM(R_M_EQ_FAC1),				"Move FAC1 to M" },
	{ MTRM(R_MULT_FAC1_SQR_FAC1),		"Double precision math (FAC1=FAC1*SQR(FAC1))" },
	{ MTRM(R_SWAP_FAC1_FAC2),			"Swap FAC1 and FAC2" },
	{ MTRM(R_SQR_FAC1_MULT_TBL),		"Square FAC1 & do table based math" },
	{ MTRM(R_TBL_BASED_MATH),			"Table based math (FAC1=(((FAC1*M)+(M+1))*(M+2)+(M+3)..." },
	{ MTRM(R_PUSH_FAC2),				"Push FAC2 on stack" },
	{ MTRM(R_PUSH_FAC1),				"Push FAC1 on stack" },
	{ MTRM(R_POP_FAC2),					"Pop FAC2 from stack" },
	{ MTRM(R_POP_FAC1),					"Pop FAC1 from stack" },
	{ MTRM(R_FP_NUMBERS),				"Floating point numbers for math operations " },
	{ MTRM(R_FP_SHARED_NUMBERS),		"Floating point num-shares 6 bytes from next number" },
	{ MTRM(R_EXP_MATH_TBL),				"Count of Floating point numbers to follow for EXP" },
	{ MTRM(R_LOG_MATH_TBL),				"Count of Floating point numbers to follow for LOG" },
	{ MTRM(R_SIN_MATH_TBL),				"Count of Floating point numbers to follow for SIN" },
	{ MTRM(R_ATN_MATH_TBL),				"Count of Floating point numbers to follow for ATN" },
	{ MTRM(R_RST_30H_FUN),				"RST 30H routine" },
	{ MTRM(R_ABS_FUN),					"ABS function" },
	{ MTRM(R_SGN_FUN),					"SGN function" },
	{ MTRM(R_PUSH_SNGL_FAC1),			"Push single precision FAC1 on stack" },
	{ MTRM(R_SNGL_FAC1_EQ_M),			"Load single precision at M to FAC1" },
	{ MTRM(R_SNGL_FAC1_EQ_BCDE),		"Load single precision in BCDE to FAC1" },
	{ MTRM(R_SNGL_BCDE_EQ_FAC1),		"Load single precision FAC1 to BCDE" },
	{ MTRM(R_SNGL_BCDE_EQ_M),			"Load single precision at M to BCDE" },
	{ MTRM(R_SNGL_DECB_EQ_M),			"Reverse load single precision at M to DEBC" },
	{ MTRM(R_SNGL_M_EQ_FAC1),			"Move single precision FAC1 to M" },
	{ MTRM(R_LOAD_FAC2_FROM_M),			"Move M to FAC2 using precision at (FB65H)" },
	{ MTRM(R_MOVE_B_BYTES_INC),			"Move B bytes from (DE) to M with increment" },
	{ MTRM(R_MOVE_B_BYTES_DEC),			"Move B bytes from (DE) to M with decrement" },
	{ MTRM(R_SNGL_CMP_BCDE_FAC1),		"Compare single precision in BCDE with FAC1" },
	{ MTRM(R_SNGL_CMP_BCDE_M),			"Compare single precision in BCDE with M" },
	{ MTRM(R_SINT_CMP),					"Compare signed integer in DE with that in HL" },
	{ MTRM(R_CMP_FAC1_FAC2),			"Compare double precision FAC1 with FAC2" },
	{ MTRM(R_CINT_FUN),					"CINT function" },
	{ MTRM(R_FAC1_EQ_SINT_HL),			"Load signed integer in HL to FAC1" },
	{ MTRM(R_CSNG_FUN),					"CSNG function" },
	{ MTRM(R_CONV_SINT_SNGL),			"Convert signed integer in FAC1 to single precision" },
	{ MTRM(R_CONV_SINT_HL_SNGL),		"Convert signed integer HL to single precision FAC1" },
	{ MTRM(R_CDBL_FUN),					"CDBL function" },
	{ MTRM(R_FIX_FUN),					"FIX function" },
	{ MTRM(R_INT_FUN),					"INT function" },
	{ MTRM(R_SINT_SUB),					"Signed integer subtract (FAC1=HL-DE)" },
	{ MTRM(R_SINT_ADD),					"Signed integer addition (FAC1=HL+DE)" },
	{ MTRM(R_SINT_MULT),				"Signed integer muliply (FAC1=HL*DE)" },
	{ MTRM(R_SINT_DIV),					"Signed integer divide (FAC1=DE/HL)" },
	{ MTRM(R_SNGL_ADD_BCDE),			"Single precision addition (FAC1=FAC1+BCDE)" },
	{ MTRM(R_SNGL_ADD_FAC2),			"Single precision addition (FAC1=FAC1+FAC2)" },
	{ MTRM(R_SNGL_SUB),					"Single precision subtract (FAC1=FAC1-BCDE)" },
	{ MTRM(R_SNGL_MULT_BCDE),			"Single precision multiply (FAC1=FAC1*BCDE)" },
	{ MTRM(R_SNGL_MULT_FAC2),			"Single precision multiply (FAC1=FAC2*FAC2)" },
	{ MTRM(R_SNGL_DIV),					"Single precision divide (FAC1=BCDE/FAC1)" },
	{ MTRM(R_SNGL_LOAD),				"Single precision load (FAC2=BCDE)" },
	{ MTRM(R_ASCII_TO_DBL),				"Convert ASCII number at M to double precision in FAC1" },
	{ MTRM(R_ASCII_FND_e),				"Found 'e' in ASCII number" },
	{ MTRM(R_ASCII_FND_E),				"Found 'E' in ASCII number" },
	{ MTRM(R_ASCII_FND_DOT),			"Found '.' in ASCII number" },
	{ MTRM(R_ASCII_FND_PERC),			"Found '%' in ASCII number" },
	{ MTRM(R_ASCII_FND_LB),				"Found '#' in ASCII number" },
	{ MTRM(R_ASCII_CONV_HELPER),		"Deal with single & double precision ASCII conversions" },
	{ MTRM(R_ASCII_CONV_HELPER2),		"Convert ASCII number that starts with a Digit" },
	{ MTRM(R_PRNT_BASIC_ERR_TERM),		"Finish printing BASIC ERROR message \" in \" line #" },
	{ MTRM(R_PRINT_HL_ON_LCD),			"Print binary number in HL at current position" },
	{ MTRM(R_PRINT_FAC1),				"Convert binary number in FAC1 to ASCII at M" },
	{ MTRM(R_PRINT_FAC1_FORMAT),		"Convert binary number in FAC1 to ASCII at M with format" },
	{ MTRM(R_FAC1_EQ_ZERO),				"Initialize FAC1 with 0.0 if it has no value" },
	{ MTRM(R_SNGL_EXP),					"Single precision exponential function" },
	{ MTRM(R_DBL_EXP),					"Double precision exponential function" },
	{ MTRM(R_INT_EXP),					"Integer exponential function" },
	{ MTRM(R_TIME_ON_STMT),				"TIME$ ON statement" },
	{ MTRM(R_TRIG_INTR),				"Trigger interrupt.  HL points to interrupt table" },
	{ MTRM(R_CLEAR_INTR),				"Clear interrupt.  HL points to interrupt table" },
	{ MTRM(R_TIME_OFF_STMT),			"TIME$ OFF statement" },
	{ MTRM(R_TIME_STOP_STMT),			"TIME$ STOP statement" },
	{ MTRM(R_CLEAR_COM_INT_DEF),		"Clear all COM), TIME), and KEY interrupt definitions" },
	{ MTRM(R_RESTORE_STMT),				"RESTORE statement" },
	{ MTRM(R_STOP_STMT),				"STOP statement" },
	{ MTRM(R_END_STMT),					"END statement" },
	{ MTRM(R_CONT_STMT),				"CONT sttement" },
	{ MTRM(R_ISALPHA_M),				"Check if M is alpha character" },
	{ MTRM(R_ISALPHA_A),				"Check if A is alpha character" },
	{ MTRM(R_CLEAR_STMT),				"CLEAR statement" },
	{ MTRM(R_NEXT_STMT),				"NEXT statement" },
	{ MTRM(R_SEND_CRLF),				"Send CRLF to screen or printer" },
	{ MTRM(R_SEND_LF),					"Send LF to screen or printer" },
	{ MTRM(R_BEEP_STMT),				"BEEP statement" },
	{ MTRM(R_HOME_CURSOR),				"Home cursor" },
	{ MTRM(R_CLS_STMT),					"CLS statement" },
	{ MTRM(R_PROTECT_LABEL),			"Protect line 8.  An ESC T is printed" },
	{ MTRM(R_UNPROT_LABEL),				"Unprotect line 8.  An ESC U is printed" },
	{ MTRM(R_STOP_AUTO_SCROLL),			"Stop automatic scrolling" },
	{ MTRM(R_RESUME_AUTO_SCROLL),		"Resume automatic scrolling" },
	{ MTRM(R_TURN_CURSOR_ON),			"Turn the cursor on" },
	{ MTRM(R_TURN_CURSOR_OFF),			"Turn the cursor off" },
	{ MTRM(R_DEL_CUR_LINE),				"Delete current line on screen" },
	{ MTRM(R_INSERT_LINE),				"Insert line a current line" },
	{ MTRM(R_ERASE_TO_EOL),				"Erase from cursor to end of line" },
	{ MTRM(R_SEND_ESC_X),				"Send ESC X" },
	{ MTRM(R_INV_CHAR_ENABLE),			"Start inverse character mode" },
	{ MTRM(R_INV_CHAR_DISABLE),			"Cancel inverse character mode" },
	{ MTRM(R_END_ESC_SEQ),				"End escape sequence" },
	{ MTRM(R_CURSOR_TO_LOW_LEFT),		"Send cursor to lower left of CRT" },
	{ MTRM(R_SET_CURSOR_POS),			"Set the current cursor position (H=Row),L=Col)" },
	{ MTRM(R_ERASE_FKEY_DISP),			"Erase function key display" },
	{ MTRM(R_SET_DISP_FKEY),			"Set and display function keys (M has key table)" },
	{ MTRM(R_DISP_FKEY_LINE),			"Display function key line" },
	{ MTRM(R_PRINT_A_TO_LCD),			"Print A to the screen" },
	{ MTRM(R_CHAR_PLOT_3),				"Character plotting level 3. Check new device console flag & call level 4)" },
	{ MTRM(R_CHAR_PLOT_4),				"Character plotting level 4. Turn off background task & call level 5" },
	{ MTRM(R_CHAR_PLOT_5),				"Character plotting level 5. Handle ESC sequences & call level 6" },
	{ MTRM(R_LCD_OUT_DRIVER),			"LCD output driver" },
	{ MTRM(R_RST_20H_LKUP_TBL),			"RST 20H lookup table" },
	{ MTRM(R_ESC_Y),					"ESC Y routine (Set cursor position)" },
	{ MTRM(R_LCD_OUT_ESC_FUN),			"LCD output Escape routine" },
	{ MTRM(R_LCD_ESC_LKUP_TBL),			"LCD Escape sequence lookup table" },
	{ MTRM(R_ESC_SEQ_DRIVER),			"ESCape sequence driver" },
	{ MTRM(R_ESC_p_FUN),				"ESC p routine (start inverse video)" },
	{ MTRM(R_ESC_q_FUN),				"ESC q routine (cancel inverse video)" },
	{ MTRM(R_ESC_U_FUN),				"ESC U routine (unprotect line 8)" },
	{ MTRM(R_ESC_T_FUN),				"ESC T routine (protect line 8)" },
	{ MTRM(R_ESC_V_FUN),				"ESC V routine (stop automatic scrolling)" },
	{ MTRM(R_ESC_W_FUN),				"ESC W routine (resume automatic scrolling)" },
	{ MTRM(R_ESC_X_FUN),				"ESC X routine" },
	{ MTRM(R_ESC_C_FUN),				"ESC C routine (move cursor right)" },
	{ MTRM(R_ESC_D_FUN),				"ESC D routine (move cursor left)" },
	{ MTRM(R_BKSPACE_FUN),				"Backspace routine" },
	{ MTRM(R_ESC_A_FUN),				"ESC A routine (move cursor up)" },
	{ MTRM(R_ESC_B_FUN),				"ESC B routine (move cursor down)" },
	{ MTRM(R_TAB_FUN),					"Tab routine" },
	{ MTRM(R_LF_FUN),					"Linefeed routine" },
	{ MTRM(R_ESC_H_FUN),				"Verticle tab and ESC H routine (home cursor)" },
	{ MTRM(R_CR_FUN),					"CR routine" },
	{ MTRM(R_ESC_P_FUN),				"ESC P routine (turn cursor on)" },
	{ MTRM(R_ESC_Q_FUN),				"ESC Q routine (turn cursor off)" },
	{ MTRM(R_ESC_M_FUN),				"ESC M routine" },
	{ MTRM(R_LCD_SCROLL),				"Scroll LCD screen A times at line number in L" },
	{ MTRM(R_ESC_L_FUN),				"ESC L routine (insert line)" },
	{ MTRM(R_GET_LCD_CHAR),				"Get character at (H),L) from LCD RAM)" },
	{ MTRM(R_ESC_l_FUN),				"ESC l routine (erase current line)" },
	{ MTRM(R_ESC_K_FUN),				"ESC K routine (erase to EOL)" },
	{ MTRM(R_CLS_FUN),					"Form Feed (0CH)), CLS), ESC E), and ESC J routine" },
	{ MTRM(R_CHAR_PLOT_6),				"Character plotting level 6.  Save character in C to LCD RAM & call level 7" },
	{ MTRM(R_ESC_J_FUN),				"ESC J routine" },
	{ MTRM(R_INP_DISP_LINE),			"Input and display line and store" },
	{ MTRM(R_INP_DISP_LINE_NO_Q),		"Input and display (no \"?\") line and store" },
	{ MTRM(R_INP_CTRL_C_HANDLER),		"Input routine Control-C handler" },
	{ MTRM(R_INP_ENTER_HANDLER),		"Input routine ENTER handler" },
	{ MTRM(R_INP_BKSP_HANDLER),			"Input routine backspace), left arrow), CTRL-H handler" },
	{ MTRM(R_INP_CTRL_U_HANDLER),		"Input routine CTRL-U & X handler" },
	{ MTRM(R_INP_TAB_HANDLER),			"Input routine Tab handler" },
	{ MTRM(R_DIM_STMT),					"DIM statement" },
	{ MTRM(R_FIND_VAR_ADDR),			"Find address of variable at M" },
	{ MTRM(R_USING_FUN),				"USING function" },
	{ MTRM(R_SEND_A_LCD_LPT),			"Send A to screen or printer" },
	{ MTRM(R_PRINT_A_EXPAND),			"Print A to printer), expanding tabs if necessary" },
	{ MTRM(R_SET_OUT_DEV_LCD),			"Reinitialize output back to LCD" },
	{ MTRM(R_LCD_CHAR_OUT_FUN),			"LCD character output routine" },
	{ MTRM(R_LCD_NEW_LINE),				"Move LCD to blank line (send CRLF if needed)" },
	{ MTRM(R_INKEY_FUN),				"INKEY$ function" },
	{ MTRM(R_GET_FILE_DESC),			"Get file descriptor for file in A" },
	{ MTRM(R_OPEN_STMT),				"OPEN statement" },
	{ MTRM(R_LCD_CLOSE_FUN),			"LCD), CRT), and LPT file close routine" },
	{ MTRM(R_RUN_STMT_PARAM),			"RUN statement (with parameters)" },
	{ MTRM(R_LOAD_STMT),				"LOAD statement" },
	{ MTRM(R_MERGE_STMT),				"MERGE statement" },
	{ MTRM(R_SAVE_STMT),				"SAVE statement" },
	{ MTRM(R_CLOSE_STMT),				"CLOSE statement" },
	{ MTRM(R_INPUT_FUN),				"INPUT$ function" },
	{ MTRM(R_CLEAR_MEM),				"Zero B bytes at M" },
	{ MTRM(R_LOAD_MEM),					"Load B bytes at M with A" },
	{ MTRM(R_PRINT_LB_INIT_FUN),		"PRINT # initialization routine" },
	{ MTRM(R_LINE_INPUT_STMT),			"LINE INPUT # statement" },
	{ MTRM(R_GEN_NM_ERR_FUN),			"Generate NM error" },
	{ MTRM(R_GEN_AO_ERR_FUN),			"Generate AO error" },
	{ MTRM(R_GEN_DS_ERR_FUN),			"Generate DS error" },
	{ MTRM(R_GEN_FF_ERR_FUN),			"Generate FF error" },
	{ MTRM(R_GEN_CF_ERR_FUN),			"Generate CF error" },
	{ MTRM(R_GEN_BN_ERR_FUN),			"Generate BN error" },
	{ MTRM(R_GEN_IE_ERR_FUN),			"Generate IE error" },
	{ MTRM(R_GEN_EF_ERR_FUN),			"Generate EF error" },
	{ MTRM(R_GEN_FL_ERR_FUN),			"Generate FL error" },
	{ MTRM(R_LOF_FUN),					"LOF function" },
	{ MTRM(R_LOC_FUN),					"LOC function" },
	{ MTRM(R_LFILES_FUN),				"LFILES function" },
	{ MTRM(R_DSKO_FUN),					"DSKO$ function" },
	{ MTRM(R_DSKI_FUN),					"DSKI$ function" },
	{ MTRM(R_DEV_NAME_TBL),				"Device name table" },
	{ MTRM(R_DCB_VCTR_TBL),				"Device control block vector addresses table" },
	{ MTRM(R_TELCOM_ENTRY),				"TELCOM Entry point" },
	{ MTRM(R_TELCOM_RE_ENTRY),			"Re-entry point for TELCOM commands" },
	{ MTRM(R_TELCOM_INST_VCTR_TBL),		"TELCOM instruction vector table" },
	{ MTRM(R_TELCOM_LABEL_TXT),			"TELCOM label line text table" },
	{ MTRM(R_TELCOM_STAT_FUN),			"TELCOM STAT instruction routine" },
	{ MTRM(R_PRINT_TELCOM_STAT),		"Print current STAT settings" },
	{ MTRM(R_SET_TELCOM_STAT),			"Set STAT and return to TELCOM ready" },
	{ MTRM(R_TELCOM_CALL_FUN),			"TELCOM CALL instruction routine" },
	{ MTRM(R_TELCOM_FIND_FUN),			"TELCOM FIND instruction routine" },
	{ MTRM(R_GO_OFFHOOK),				"Go off-hook" },
	{ MTRM(R_DISCONNECT_PHONE),			"Disconnect phone line and disable modem carrier" },
	{ MTRM(R_CONNECT_PHONE),			"Connect phone line and enable modem carrier" },
	{ MTRM(R_GO_OFFHOOK_WAIT),			"Go off-hook and wait for carrier" },
	{ MTRM(R_TELCOM_PAUSE),				"Pause for about 2 seconds" },
	{ MTRM(R_EXEC_LOGON_SEQ),			"Execute logon sequence at M" },
	{ MTRM(R_DIALING_FUN),				"Dialing routine" },
	{ MTRM(R_AUTO_LOGIN_SEQ),			"Auto logon sequence" },
	{ MTRM(R_DIAL_DIGIT),				"Dial the digit in A & print on LCD" },
	{ MTRM(R_TELCOM_TERM_FUN),			"TELCOM TERM instruction routine" },
	{ MTRM(R_TELCOM_DISPATCH),			"TELCOM \"dispatcher\" routine" },
	{ MTRM(R_TELCOM_PREV_FUN),			"TELCOM PREV function routine" },
	{ MTRM(R_TELCOM_FULL_FUN),			"TELCOM FULL/HALF function routine" },
	{ MTRM(R_TELCOM_ECHO_FUN),			"TELCOM ECHO function routine" },
	{ MTRM(R_TELCOM_UP_FUN),			"TELCOM UP function routine" },
	{ MTRM(R_TELCOM_DOWN_FUN),			"TELCOM DOWN function routine" },
	{ MTRM(R_TELCOM_BYE_FUN),			"TELCOM BYE function routine" },
	{ MTRM(R_MENU_ENTRY),				"MENU Program" },
	{ MTRM(R_DISP_DIR),					"Display directory entries" },
	{ MTRM(R_MENU_CTRL_U_HANDLER),		"Handle CTRL-U key from MENU command loop" },
	{ MTRM(R_MENU_CMD_LOOP),			"MENU Program command loop" },
	{ MTRM(R_MENU_BKSP_HANDLER),		"Handle Backspace key from MENU command loop" },
	{ MTRM(R_MENU_ENTER_HANDLER),		"Handle ENTER key from MENU command loop" },
	{ MTRM(R_EXEC_ROM_FILE),			"Launch ROM command file from MENU program" },
	{ MTRM(R_DISP_DIR_TYPE_C),			"Display directory entries of type in register C" },
	{ MTRM(R_CONV_FILENAME),			"Convert filename from space padded to '.ext' format" },
	{ MTRM(R_NEXT_DIR_ENTRY),			"Position cursor for next directory entry" },
	{ MTRM(R_CLS_PRINT_TIME_DAY),		"Print time), day and date on first line of screen" },
	{ MTRM(R_PRINT_TIME_DAY),			"Print time),day),date on first line w/o CLS" },
	{ MTRM(R_PRINT_STRING2),			"Print NULL terminated string at M" },
	{ MTRM(R_COPY_MEM_DE_M),			"Copy A bytes from (DE) to M" },
	{ MTRM(R_CMP_MEM_DE_M),				"Compare string at DE with that at M (max C bytes)" },
	{ MTRM(R_CLEAR_FKEY_TBL),			"Clear function key definition table" },
	{ MTRM(R_SET_FKEYS),				"Set new function key table" },
	{ MTRM(R_DISP_FKEYS),				"Display function keys on 8th line" },
	{ MTRM(R_SEARCH_DIR),				"Search directory for filename" },
	{ MTRM(R_GET_FILE_ADDR),			"Get start address of file at M" },
	{ MTRM(R_ADDRSS_ENTRY),				"ADDRSS Entry point" },
	{ MTRM(R_ADDRSS_ENTRY_W_FILE),		"ADDRSS entry with (DE) pointing to filename" },
	{ MTRM(R_SCHEDL_ENTRY),				"SCHEDL Entry point" },
	{ MTRM(R_SCHEDL_ENTRY_W_FILE),		"SCHEDL entry with (DE) pointing to filename" },
	{ MTRM(R_ADDRSS_FIND_FUN),			"FIND instruction for ADDRSS/SCHEDL" },
	{ MTRM(R_ADDRSS_LFND_FUN),			"LFND instruction for ADDRSS/SCHEDL" },
	{ MTRM(R_FIND_TEXT_IN_FILE),		"Find text at M in the file at (DE)" },
	{ MTRM(R_FIND_NEXT_LINE_IN_FILE),	"Increment DE past next CRLF in text file at (DE)" },
	{ MTRM(R_CHECK_FOR_CRLF),			"Check next byte(s) at (DE) for CRLF" },
	{ MTRM(R_ADDRSS_INST_VCTR_TBL),		"ADDRSS/SCHEDL instruction vector table" },
	{ MTRM(R_GET_KEY_CONV_TOUPPER),		"Wait for char from keyboard & convert to uppercase" },
	{ MTRM(R_SEND_CURSOR_HOME),			"Home cursor" },
	{ MTRM(R_PRINT_TIME_LOOP),			"Print time on top line until key pressed" },
	{ MTRM(R_TEXT_ENTRY),				"TEXT Entry point" },
	{ MTRM(R_TEXT_FKEY_TBL),			"TEXT Function key table - empty" },
	{ MTRM(R_EDIT_STMT),				"EDIT statement" },
	{ MTRM(R_WAIT_FOR_SPACE_KEY),		"Wait for a space to be entered on keyboard" },
	{ MTRM(R_EDIT_DO_FILE_FUN),			"Edit .DO files" },
	{ MTRM(R_TEXT_EDIT_LOOP),			"Main TEXT edit loop" },
	{ MTRM(R_TEXT_CTRL_VCTR_TBL),		"TEXT control character vector table" },
	{ MTRM(R_TEXT_ESC_FUN),				"TEXT ESCape routine" },
	{ MTRM(R_TEXT_CTRL_P_FUN),			"TEXT control P routine" },
	{ MTRM(R_TEXT_CTRL_I_FUN),			"TEXT control I routine" },
	{ MTRM(R_TEXT_CTRL_M_FUN),			"TEXT control M routine" },
	{ MTRM(R_TEXT_CTRL_D_FUN),			"TEXT right arrow and control D routine" },
	{ MTRM(R_TEXT_CTRL_X_FUN),			"TEXT down arrow and control X routine" },
	{ MTRM(R_TEXT_CTRL_H_FUN),			"TEXT control H routine" },
	{ MTRM(R_TEXT_CTRL_S_FUN),			"TEXT left arrow and control S routine" },
	{ MTRM(R_TEXT_CTRL_E_FUN),			"TEXT up arrow and control E routine" },
	{ MTRM(R_TEXT_CTRL_F_FUN),			"TEXT control F routine" },
	{ MTRM(R_TEXT_CTRL_A_FUN),			"TEXT control A routine" },
	{ MTRM(R_TEXT_CTRL_T_FUN),			"TEXT control T routine" },
	{ MTRM(R_TEXT_CTRL_B_FUN),			"TEXT control B routine" },
	{ MTRM(R_TEXT_CTRL_R_FUN),			"TEXT control R routine" },
	{ MTRM(R_TEXT_CTRL_Q_FUN),			"TEXT control Q routine" },
	{ MTRM(R_TEXT_CTRL_W_FUN),			"TEXT control W routine" },
	{ MTRM(R_TEXT_CTRL_Z_FUN),			"TEXT control Z routine" },
	{ MTRM(R_TEXT_CTRL_L_FUN),			"TEXT control L routine" },
	{ MTRM(R_TEXT_CTRL_C_FUN),			"TEXT control C routine" },
	{ MTRM(R_TEXT_GET_NEXT_BYTE),		"Get next byte for TEXT Program entry" },
	{ MTRM(R_TEXT_CTRL_O_FUN),			"TEXT control O routine" },
	{ MTRM(R_TEXT_CTRL_U_FUN),			"TEXT control U routine" },
	{ MTRM(R_TEXT_CTRL_N_FUN),			"TEXT control N routine" },
	{ MTRM(R_COPY_NULL_STRING),			"Copy NULL terminated string at M to (DE)" },
	{ MTRM(R_TEXT_CTRL_Y_FUN),			"TEXT control Y routine" },
	{ MTRM(R_TEXT_CTRL_G_FUN),			"TEXT control G routine" },
	{ MTRM(R_TEXT_CTRL_V_FUN),			"TEXT control V routine" },
	{ MTRM(R_INSERT_A_INTO_FILE),		"Insert A into text file at M" },
	{ MTRM(R_INSERT_SPACES),			"Insert BC spaces at M" },
	{ MTRM(R_DELETE_CHARS),				"Delete BC characters at M" },
	{ MTRM(R_MOVE_BC_BYTES_INC),		"Move BC bytes from M to (DE) with increment" },
	{ MTRM(R_MOVE_BC_BYTES_DEC),		"Move BC bytes from M to (DE) with decrement" },
	{ MTRM(R_BASIC_ENTRY),				"BASIC Entry point" },
	{ MTRM(R_LOAD_BASIC_FKEYS),			"Copy BASIC Function key table to key definition area" },
	{ MTRM(R_RE_INIT_SYSTEM),			"Re-initialize system without destroying files" },
	{ MTRM(R_WARM_RESET),				"Warm start reset entry" },
	{ MTRM(R_SEND_A_TO_LPT),			"Send character in A to the printer" },
	{ MTRM(R_CHECK_RS232_QUEUE),		"Check RS232 queue for pending characters" },
	{ MTRM(R_READ_RS232_QUEUE),			"Get a character from RS232 receive queue" },
	{ MTRM(R_RST_6_5_FUN),				"RST 6.5 routine (RS232 receive interrupt)" },
	{ MTRM(R_INC_RS232_QUEUE_IN),		"Calculate address to save next RS232 character" },
	{ MTRM(R_SEND_XON),					"Send XON (CTRL-Q) out RS232" },
	{ MTRM(R_DISABLE_XON_XOFF),			"Turn off XON/XOFF protocol" },
	{ MTRM(R_SEND_A_USING_XON),			"Send character in A to serial port using XON/XOFF" },
	{ MTRM(R_SEND_C_TO_RS232),			"Send character in C to serial port" },
	{ MTRM(R_XON_XOFF_HANDLER),			"Handle XON/XOFF protocol" },
	{ MTRM(R_SET_RS232_BAUD_RATE),		"Set RS232 baud rate stored in H" },
	{ MTRM(R_RS232_BAUD_TIMER_VALS),	"RS232 baud rate timer values" },
	{ MTRM(R_INIT_RS232_MDM),			"Initialize RS232 or modem" },
	{ MTRM(R_UNINIT_RS232_MDM),			"Deactivate RS232 or modem" },
	{ MTRM(R_CLICK_SND_PORT),			"Click sound port if sound enabled" },
	{ MTRM(R_CHECK_CD),					"Check for carrier detect" },
	{ MTRM(R_ENABLE_XON_XOFF),			"Enable XON/OFF when CTRL-S / CTRL-Q sent" },
	{ MTRM(R_INIT_SER_BUF_PARAMS),		"Initialize serial buffer parameters" },
	{ MTRM(R_CAS_WRITE_HEADER),			"Write cassette header and sync byte" },
	{ MTRM(R_CAS_WRITE_NO_CHKSUM),		"Write char in A to cassette w/o checksum" },
	{ MTRM(R_CAS_WRITE_NO_SYNC),		"Write char in A to cassette w/o checksum or sync bit" },
	{ MTRM(R_CAS_WRITE_BIT),			"Write bit 0 of A to cassette" },
	{ MTRM(R_CAS_READ_HEADER),			"Read cassette header and sync byte" },
	{ MTRM(R_CAS_READ_BIT),				"Read Cassette port data bit" },
	{ MTRM(R_CAS_COUNT_BITS),			"Count and pack cassette input bits" },
	{ MTRM(R_CAS_READ_NO_CHKSUM),		"Read character from cassette w/o checksum" },
	{ MTRM(R_CAS_REMOTE_FUN),			"Cassette REMOTE routine - turn motor on or off" },
	{ MTRM(R_KEYSCAN_MGT_FUN),			"Keyboard scanning management routine" },
	{ MTRM(R_KEY_DETECTION),			"Key detection -- Determine which keys are pressed" },
	{ MTRM(R_KEY_REPEAT_DET),			"Key repeat detection" },
	{ MTRM(R_GET_KEY_MATRIX),			"Calculate key matrix position and save buffer pointer at FFA8H" },
	{ MTRM(R_INIT_KEY_RPT_CNT),			"Key detected - initialize repeat counter and decode" },
	{ MTRM(R_KEY_DECODE),				"Key decoding" },
	{ MTRM(R_KEY_FIRST_IN_BUF),			"Keyboard buffer management - place key in new buffer" },
	{ MTRM(R_KEY_ADD_TO_BUF),			"Keyboard buffer management - place subsequent key in buffer" },
	{ MTRM(R_ISR_EXIT_FUN),				"Interrupt exit routine (pop all regs & RET)" },
	{ MTRM(R_UNSHIFTED_KEY),			"Handle unshifted & non-CTRL key during key decoding" },
	{ MTRM(R_ARROW_KEY),				"Handle Arrow keys during key decoding" },
	{ MTRM(R_CAPS_LOCK_KEY),			"Handle CAPS LOCK key during key decoding" },
	{ MTRM(R_NUM_KEY),					"Handle NUM key during key decoding" },
	{ MTRM(R_SCAN_KEYBOARD),			"Scan keyboard for character (CTRL-BREAK ==> CTRL-C)" },
	{ MTRM(R_ENABLE_INTERRUPTS),		"Enable interrupts as normal" },
	{ MTRM(R_CHK_PENDING_KEYS),			"Check keyboard queue for pending characters" },
	{ MTRM(R_CHK_BREAK),				"Check for break or wait (CTRL-S)" },
	{ MTRM(R_CHK_SHIFT_BREAK),			"Check if SHIFT-BREAK is being pressed" },
	{ MTRM(R_SCAN_SPECIAL_KEYS),		"Scan BREAK),CAPS),NUM),CODE),GRAPH),CTRL),SHIFT & set bits in A" },
	{ MTRM(R_GEN_TONE),					"Produce a tone of DE freq and B duration" },
	{ MTRM(R_GET_CLK_CHIP_REGS),		"Copy clock chip regs to M" },
	{ MTRM(R_PUT_CLK_CHIP_REGS),		"Update clock chip regs from M" },
	{ MTRM(R_READ_CLK_CHIP_BIT),		"Read next bit from Clock Chip" },
	{ MTRM(R_SET_CLK_CHIP_MODE),		"Set clock chip mode" },
	{ MTRM(R_BLINK_CURSOR),				"Blink the cursor" },
	{ MTRM(R_PLOT_POINT),				"Plot (set) point (D),E) on the LCD" },
	{ MTRM(R_CHAR_PLOT_7),				"Character plotting level 7.  Plot character in C on LCD at (H),L)" },
	{ MTRM(R_CLEAR_POINT),				"Clear (reset) point (D),E) on the LCD" },
	{ MTRM(R_LCD_BYTE_PLOT),			"Byte Plot - Send bit pattern to LCD for character" },
	{ MTRM(R_ENABLE_LCD_DRIVER),		"Enable LCD drivers after short delay" },
	{ MTRM(R_WAIT_LCD_DRIVER),			"Wait for LCD driver to be available" },
	{ MTRM(R_LCD_BIT_PATTERNS),			"8155 PIO chip bit patterns for LCD drivers" },
	{ MTRM(R_DELAY_FUN),				"Delay routine - decrement C until zero" },
	{ MTRM(R_SET_INTR_1DH),				"Set interrupt to 1DH" },
	{ MTRM(R_BEEP_FUN),					"Beep routine" },
	{ MTRM(R_CLICK_SOUND_PORT),			"Click sound port" },
	{ MTRM(R_CHK_XTRNL_CNTRLER),		"Check for optional external controller" },
	{ MTRM(R_XTRNL_CNTRLER_DRIVER),		"Optional external controller driver" },
	{ MTRM(R_LCD_CHAR_SHAPE_TBL1),		"LCD char generator shape table (20H-7FH" },
	{ MTRM(R_LCD_CHAR_SHAPE_TBL2),		"LCD char generator shape table (80H-FFH)" },
	{ MTRM(R_KEYBOARD_CONV_MATRIX),		"Keyboard conversion matrix" },
	{ MTRM(R_BOOT_ROUTINE),				"Boot routine" },
	{ MTRM(R_COLD_BOOT),				"Cold boot routine" },
	{ MTRM(R_DISP_MODEL),				"Display TRS-80 Model number & Free bytes on LCD" },
	{ MTRM(R_DISP_FREE_BYTES),			"Display number of free bytes on LCD" },
	{ MTRM(R_INIT_RST_38H_TBL),			"Initialize RST 38H RAM vector table" },
	{ MTRM(R_CALC_FREE_RAM),			"Calculate physical RAM available" },
	{ MTRM(R_INIT_CLK_CHIP_REGS),		"Initial clock chip register values" },
	{ MTRM(R_MENU_TEXT_STRINGS),		"MENU Text Strings" },
	{ MTRM(R_RST_38H_DRIVER),			"RST 38H RAM vector driver routine" },
	{ MTRM(R_RST_5_5_VECTOR),			"RST 5.5 RAM Vector" },
	{ MTRM(R_RST_6_5_VECTOR),			"RST 6.5 RAM Vector" },
	{ MTRM(R_RST_7_5_VECTOR),			"RST 7.5 RAM Vector" },
	{ MTRM(R_TRAP_VECTOR),				"RAM vector for TRAP interrupt" },
	{ MTRM(R_DETECT_OPTION_ROM),		"Detect Option ROM" },
	{ MTRM(R_BASIC_RUNNING),		    "BASIC Program Running Flag" },
	{ MTRM(R_INIT_BASIC_VARS),			"Initialize BASIC Variables for new execution" },
	{ MTRM(R_INIT_TEMP3),			    "Initialize FP_TEMP3 for new program" },
	{ MTRM(R_RENUM_STMT),			    "RENUM Statement" },
	{ MTRM(R_TEST_COM_TOKEN),		    "Test for COM token (ON COM Statement)" },
	{ MTRM(R_CMD_STMT),					"CMD Statement" },
	{ MTRM(R_LOCATE_STMT),				"LOCATE Statement" },
	{ MTRM(R_COLOR_STMT),				"COLOR Statement" },
	{ MTRM(R_EXEC_STMT),				"EXEC Statement" },
	{ MTRM(R_BSAVE_STMT),				"BSAVE Statement" },
	{ MTRM(R_BLOAD_STMT),				"BLOAD Statement" },
	{ MTRM(R_DSKF_FUN),					"DSKF Function" },
	{ MTRM(R_FORMAT_FUN),				"FORMAT Function" },
	{ MTRM(R_PORT_90H),					"Current value of OUT port 90H" },
	{ MTRM(R_RST0_HOOK),				"RST 0 Hook" },
	{ MTRM(R_EXEC_2ND_ROM),				"Hook to execute Option ROM" },
	{ MTRM(R_TELCOM_FKEY_VCTR),			"Main TELCOM Funciton Key Vector Table" },
	{ MTRM(R_UNUSED),					"Unused Space" },
	{ MTRM(R_UPDATE_SYS_PTRS),			"Update system pointers for .DO), .CO), vars), etc." },
	{ MTRM(R_SAVE_TO_CATALOG),			"Save new entry to Catalog" },
	{ MTRM(R_PROC_SAVEM_ARGS),			"Process SAVEM Arguments" },
	{ MTRM(R_CLOAD_ONERR),				"On-error return handler for CLOAD statement" },
	{ MTRM(R_LOAD_CO_HEADER),			"Copy .CO 6-byte header to Current Program Area" },
	{ MTRM(R_MEMCPY_CALL_ARGS),			"Memory copy using args following the CALL statement" },
	{ MTRM(R_RST_1),					"RST 1 Vector" },
	{ MTRM(R_RST_2),					"RST 2 Vector" },
	{ MTRM(R_RST_3),					"RST 3 Vector" },
	{ MTRM(R_RST_4),					"RST 4 Vector" },
	{ MTRM(R_RST_5),					"RST 5 Vector" },
	{ MTRM(R_RST_6),					"RST 6 Vector" },
	{ MTRM(R_RST_7),					"RST 7 Vector" },
	{ (void *) 0, -1, "" },
};
